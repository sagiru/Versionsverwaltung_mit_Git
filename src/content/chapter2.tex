\chapter{Versionsverwaltung}\label{cha:Versionsverwaltung}
\section{Definition}\label{sec:Definition}
Versionskontrollsysteme sind auch bekannt als Versionsverwaltungssysteme (engl.
\acrlong{vcs}), Quellcode Verwaltung(engl. Source Control) oder
Revisionskontollsysteme(engl. Revision Control System). Mit diesen Begriffen
sind Systeme gemeint die es Entwicklern, Teams oder Organisationen erlauben
eine vollständige Historie mit allen Änderungen an dem Quellcode ihrer
gemeinsam entwickelten Software zu verwalten. Ausschlaggebend ist hierbei das
für alle Nutzer transparent wird wer, wann und vor allem warum welche
Änderungen durchgeführt hat. Eine weiterer wichtige Eigentschaft ist das es
verschiedenen Teams eine Zusammenarbeit an ggf\. verschiedenen Teilen der
Software ermöglicht ohne sich gegenseitig zu
behindern\footnote{\label{dev:1}Das hängt natürlich nicht nur von dem
Versionskontollsystem ab sondern auch von dem Design der entwickelten Software.
Diese wird i.d.R. eher modular aufgebaut so das die Möglichkeit einer paralelle
Entwicklung unterstützt wird.}.\cite[s.~381]{cd}\\

Es wird in nachvolgenden Abschnitten nicht im Detail auf alle existierende
Versionskontollsysteme eingegangen. Viel mehr wird ein kleiner Ausschnitt
vorgestellt von wenigen Systemen der dazu dienen einen Überblick über die
grundlegende Entwicklung von \glspl{vcs} zu vermitteln.

\section{Geschichtliche Entwicklung}\label{sec:GeschichtlicheEntwicklung}
Das erste Versionskontrollsystem namens SCCS enstand 1972 und wurde von Marc J.
Rockkind bei Bell Labs
geschrieben\footnote{\url{http://www.belllabs.com/}}\cite[s.~382]{cd}. Ab diesem
Zeitpunkt enstand eine Vielzahl von verschiedenen Versionskontollsystemen.  Als
Alternative zu dem properitären \acrshort{sccs} folgte Anfang 1980 das von
Walter F. Tichy an Purdue University entwickelte erste \acrlong{OpenSource}
Versionskontrollsystem \acrfull{rcs}\cite{paper:rcs,link:rcs}. Ross Ridge
veröffentlichte 1993 mit einer Beta Version von \acrshort{mysc} einen freien
Ersatz für \acrshort{sccs}. In späteren Versionen wurde \acrshort{mysc} in
\acrfull{cssc} umbenannt\cite{link:cssc,link:mysc}. Alle drei Systeme finden in
der Praxis nur noch wenig Anwendung und daher wird an dieser Stelle nicht auf
weiter auf Details eingegangen.

\subsection{CVS}\label{sec:cvs}
Das 1986 durch Dick Grune veröffentlichte \acrfull{cvs} war das erste freie
Versionskontrollsystem mit einem zentralen \gls{repository}. Das wurde ereicht
in dem \acrshort{rcs}, mit Hilfe eines \gls{wrapper}, um eine
Client-/Serverkomponente erweitert wurde. Das ermöglichte erstmals das mehrere
Entwickler gleichzeitig an einem \gls{repository} und konkurrierend an den
selben Dateien arbeiten konnten. Neben dem innovativen Ansatz gabe es hier aber
noch einige technische Einschränkungen die ein kollaboratives Arbeiten
erschwerten. So war z.B. die Nutzung des verbrauchten Speicherplatzes nicht
optimal. Das erzeugen von Abzweigungen (Branches) wurde durch einfaches
Kopieren erreicht. Das war deshalb nicht nur Zeitaufwändig sondern verbrauchte
auch entsprechenden Speicherplatz. Ein späteres Zusammenführen (mergen) dieser
Zweige führte daher zu Dateikonflikten und verursachte hierduch erheblichen
Aufwand. Auch gab es keine Funktonalität Binärdateien zu verwalten so das hier
der Speicherplatz auch eher ineffizient genutzt wurde. Das erstellen von Tags
war mit wachsendem Inhalt des \glspl{repository} ebenfalls Zeitaufwändig da
alle enthaltenen Dateien bearbeitet werden mussten. Eine der, aus heutiger
Sicht, größte Einschränkung war aber sicher die Tatsache das Commits in das
\gls{repository} nicht Atomar waren. Wurde die Übertragung der Dateien in das
zentrale \gls{repository} unterbrochen so wurde dieses in einem inkonsistenten
und nicht nutzbaren Zustand hinterlassen und musste administrativ repariert
werden. \cite[s.~382-383]{cd}

\subsection{SVN}\label{sec:svn}
Das Ziel des als quasi Nachfolger zu \acrshort{cvs} entwickelten
Versionsverwaltungssystem \acrfull{svn} war es die technischen Einschränkungen
von \acrshort{cvs} zu beheben. Es wurde darauf geachtet das es als Ersatz
fungieren kann und einen Umstieg möglichst einfach zu machen. Ebenso
funktioniert das Benutzerinterface ähnich zu \acrshort{cvs} so das Entwickler
sich nach einem Umstieg leichter zurecht finden. Als zentrale Neuerung wird
hier, im Gegensatz zu \acrshort{rcs} und \acrshort{sccs} sind nicht mehr die
Dateien zentraler Bestandteil der Versionierung sondern die sogenannte SVN
Revision. Jede Revision enthält einen eindeutigen Stand aller Dateien im
\gls{repository} zu einem bestimmten Zeitpunkt und ist global gültig und
eindeutig. Das ermöglicht konkrete Vergleiche welche Veränderungen zwischen
zwei Revisionen durchgeführt wurden. Alle Änderungen, wie z.b. das Kopieren,
Hinzufügen oder Entfernen von Dateien werden Atomar durchgeführt. Im Gegensatz
zu \acrshort{cvs} geht die Historie einer Datei nicht verloren wenn Sie kopiert
wird. Das erstellen von Tags oder Branches wurde ebenfalls verbessert. Hierzu wurde eine Konvention eingeführt die drei verschiedene Verzeichnisse innerhalb eines \glspl{repository} vorgibt.
\begin{itemize}
\item \textbf{trunk}: Enthält die Revision an der gemeinsam gearbeitet wird
       und von der Branches und Tags erzeugt werden.
\item \textbf{tags}: Verzeichnis in dem unterschiedliche Verzeichnisse als
       Tags erzeugt werden die von einer bestimmten Revision erzeugt werden.
\item \textbf{branches}: Verzeichnis in dem unterschiedliche Verzeichnisse als
      Abzweigungen angelegt werden. Hierauf kann unabhängig von \textit{trunk}
      gearbeitet werden.
\end{itemize}
Die o.a. Verzeichnsse bzw. Tags und Branches sind lediglich Zeiger auf eine
bestimmte Revision und die Trennung dazwischen ist nur eine Konvention. So
werden Tags und Branches erzeugt in dem ein Verzeichnis angelegt wird und der
Inhalt von \textit{trunk} kopiert wird. Das führt auch zu einem der Probleme
bei dem Arbeiten mit \acrlong{svn}. Tags sind nicht eindeutig und veränderbar.
So macht SVN technisch keinen Unterschied zwischen \textit{trunk},
\textit{tags}, \textit{branches} oder einem beliebigen anderen Verzeichnis.
Alle können in der gleichen Art und Weise bearbeitet werden. Eine weiterer
Vorteil ist, das mit \acrlong{svn} auch gearbeitet werden kann wenn das
Netzwerk nicht zur Verfügung. Alle Änderungen an Dateien werden i.d.R.  erstmal
auf einer lokalen Kopie durchgeführt und mit einem seperaten Kommando an das
zentrale Repository gesendet. Als weitere Funktionalität seien noch sogenannte
Externals genannt die es erstmals ermöglichen Inhalte von anderen Repositorys
einzubinden. Dies kann nützlich sein um Abhängigkeiten zwischen
unterschiedlicher Software oder \glspl{repository} abzubilden oder Binärdateien
auszulagern. \acrlong{svn} war zwar eine erhebliche Neuerung gegenüber
\acrlong{cvs} hatte aber aufgrund der zusätzlichen Client-/Server Komponente
einige neue Probleme. So waren z.B. zwar die Aktionen auf seiten des zentralen
\glspl{repository} atomar aber nicht auf seiten des Clients. So das hier, bei
unvorhergesehenen Fehlern, wieder Inkonsistenzen entstehen konnten.  Des
weiteren verwaltet \acrshort{svn} mit Hilfe eines Verzeichnisses \textit{.svn}
innerhalb eines jeden Verzeichnisses. Innerhalb dieses Ordners werden
Verwaltungsinformationen gespeichert. Das ermöglicht eine unabhängige
Verwaltung aller Verzeichnisse untereinander und führt ggf\. dazu das die
lokale Kopie eine Zusammenstellung von unterschiedlichen Revisionen ist und
keinen eindeutigen Stand representiert. Das sind nur einige der Probleme mit
SVN auf eine weitere Ausführung wird aus Platzgründen verzichtet und kann in
einschlägiger Literatur nachgelesen werden.\cite[s.~383-385]{cd}

\subsection{Git}\label{git}
Git ist ein verteiltes bzw. dezentrales \acrlong{vcs:de}. Es wurde von Linux
Torvalds und Junio Hamano entwickelt und ist für die gängigen Platformen wie
Linux, BSD und Windows u.a. verfügbar. Der Name Git kommt nach einem Zitat von
Linux Torvalds wie folgt zustande\cite{link:gitfaq}:

\begin{center}
\textit{\glqq{}I'm an egotistical bastard, and I name all my projects after
myself. First 'Linux', now 'Git'\grqq{}}\\
\end{center}

Alternativ stellt Linux Torvalds noch
weitere Varianten als Acronym für Git zur Verf\-ügung\cite{link:gitfaq}:

\begin{itemize}
  \item \textit{\glqq{}Random three-letter combination that is pronounceable, and not
  actually used by any common UNIX command. The fact that it is a
  mispronunciation of "get" may or may not be relevant.\grqq{}}
  \item \textit{\glqq{}Stupid. Contemptible and despicable. Simple. Take your pick from the
  dictionary of slang.\grqq{}}
  \item \textit{\glqq{}Global information tracker": you're in a good mood, and it actually
  works for you. Angels sing and light suddenly fills the room.\grqq{}}
  \item \textit{\glqq{}Goddamn idiotic truckload of sh*t": when it breaks\grqq{}}
\end{itemize}

Linux Torvalds nutzte ursprünglich als Versionsverwaltung das kommerzielle System BitKeeper für
die Entwicklung am Linux
Kernel\footnote{\url{https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git}}.
Nach Unstimmigkeiten mit dem Hersteller von BitKeeper entschloss Linux Tovalds
sich dazu ein neues \gls{vcs:de} zu schreiben. Dieses sollte weit mehr als
eine Alternative zu den bisherigen sein\cite[s.~13]{gitosp}. So lautete 2005
eine Aussage von Linus Torvalds zu \acrshort{cvs}\cite[s.~385]{cd}:

\begin{center}
\textit{\glqq{}There is no way to do CVS right\grqq{}}\\
\end{center}

Neben dem beheben der Probleme mit denen die populären Systeme (Abschnitt
\ref{sec:svn} und \ref{sec:cvs}) zu kämpfen hatten sollte der zentrale
Augenmerk auf Geschwindigkeit und Integrität liegen. Schon wenige Wochen nach
dem Start der Arbeit an Git konnten die ersten Versionen bereits Quellkode
verwalten. Die grundlegenden Konzepte sind bis heute gleich geblieben. Die
spätere erfolgreiche Migration und Verwaltung des Linux Kernel
\glspl{repository} mit Git führte zu einem hohen ansehen und einer starken
Verbreitung von Git. Die Anforderungen an ein \gls{vcs:de} um den Linux Kernel
mit über 1000 Entwicklern zu verwalten sind immens. Allein zwischen zwei
Versionen finden sich mehrere hunderttausend Änderungen in über 1000 Dateien
und etliche Merges zwischen verschiedenen Branches (Abschnitt
\ref{cha:kernel}). Git selbst ist heutzutage insbesonderen bei großen Projekten
kaum mehr wegzudenken.\cite[s.~13]{gitosp}

\section{Kollaboration}
Die Möglichkeit Änderungen transparent und nachvollziehbar in einem
\gls{repository} zu speichern und bei Bedarf wieder zurückzunehmen oder Stände
die zu unterschiedlichen Zeitpunkten erzeugt wurden zu vergleichen,
zusammenzuführen  und Teile davon wieder herzustellen ermöglicht es die
Zusammenarbeit in Teams oder Organisationen erheblich zu verbessern. Alle
beteiligten werden damit konfrontiert das mehrere Personen und Teams an
gleichen Inhalten zur gleichen Zeit arbeiten müssen. Das verbessert den Umgang
mit Konflikten, seien sie technischer oder organisatorischer Art, die eben
durch eine solche Zusammenarbeit enstehen konnen. Der frühe Einsatz eines
\acrlong{vcs:de} sollte als eine gute Angewohnheit angesehen werden die einen
positiven Einfluss auf die Zusammenarbeit hat. Da nicht alle die gleichen
Funktionen unterstützen sollte bei der Auswahl des einzusetztenden
Systems darauf geachtet werden welche Eigenschaften der Zusammenarbeit
gefördert werden sollen. So könnten das nach Jennifer Davis und Katherine
Daniels in \cite[S.~178]{effdo} z.B. folgende sein:

\begin{itemize}
\item erstellen und abzweigen von Repositories,
\item beitragen zu Repositories bwz. das verwalten von Beiträgen,
\item festlegen von Prozessen oder
\item das verwalten von Berechtigungen innerhalb von Repositories.
\end{itemize}

Der Einsatz eines \acrlong{vcs:de} hat auch einen Einfluss auf Risiken die
beispielsweise bei Änderungen an einer produktiven Softwareplattform (z.B.
eines Internetportals) enstehen. Hierdurch wird es möglich, im Fehlerfall, eine
frühere Version der Software wieder einzusetzten und eben solche Risiken zu
verringern.\cite[S.~178]{effdo}

Ein \acrlong{vcs:de} ist auch nicht nur zum Versionieren von Quellcode
geeignet. Eine Aussage von Jez Humble und David Farley in \cite[S.~33]{cd}
lautet hierzu:

\begin{center}
\glqq{}Keep Absolutely Everything in Verison Control\grqq{}
\end{center}

Jede Datei die benötigt wird um die Software reproduzierbar zu erzeugen und zu
verwalten sollte sich unter Versionskontolle befinden. Das können beliebige
Dateien sein wie z.B.

\begin{itemize}
\item Quellcode,
\item Tests,
\item Skripte zum Kompilieren oder zur Datenbankverwaltung,
\item Bibliotheken oder
\item Konfigurationen.
\end{itemize}

So können neue Mitarbeiter schnell in Teams integriert werden und ein
effizienter Start wird gefördert. Es ist ebenfalls wichtig das alle
benötigten Informationen mit unter Versionskontolle sind und allen zur
Verfügung stehen. Hierzu gehören neben Dokumentationen auch z.B. Projekt- und
Releasepläne der Manager oder Dokumente über durchgeführte Analysen. Darüber
hinaus sollten auch externe Abhängigkeiten mit verwaltet werden. So könnten
hier ebenso

\begin{itemize}
\item DNS Zonendateien,
\item Regeln für eine Firewall oder
\item die Konfiguration für eine Entwicklungsumgebung mit versioniert werden.
\end{itemize}

Im Kern alles was nötig ist um Umgebungen (insbesondere test und
produktive\footnote{Es gibt sicher eine Vielzahl von Szenarien die es als
wirtschaftlich arbeitenes Unternehmen erfordern zu so etwas in der Lage zu
sein. Ausgenommen vielleicht Anbieter einschlägiger Suchmaschinen die nicht
z.B. von dem abbrennen eines einzelnen Datenzentrums abhängig sind.}) von Grund
auf neu zu erzeugen. Erst wenn all diese Informationen und Dateien, die sich
über die Zeit verändern, in einem Versionskontrollsystem verwaltet werden ist
es möglich das Projekt oder die Software von/zu einem beliebigen Zeitpunkt in
der Historie wieder herzustellen. \cite[S.~33]{cd}

\section{Allgemeine Grundlagen}\label{sec:Grundlagen}
Aus den vorhergehenden Abschnitten lässt sich zusammenfassend feststellen das
für den gemeinsamen Zugriff auf Dateien bestimmte Forderungen aus Sicht der
Benutzer gibt. Nach \cite[S.~37]{hagen:1678} bestehen Forderungen nach
\textbf{Konsistenz}, \textbf{Isolation}, \textbf{Integration},
\textbf{Aktualität}, \textbf{Gruppenwahrnehmung} und
\textbf{Nachvollziehbarkeit}. So sollen Entwickler in der Lage sein immer an
einer gültigen Fassung einer Datei zu arbeiten als sei diese Datei exklusiv für
sie reserviert und die eigenen Änderungen daran wieder so wieder zu integrieren
das eine Nachvollziehbarkeit mit einer Änderungshistorie die wenigstens Namen
und Datum enthält zu gewährleistet ist.  Wie die praktische Umsetzung dieser
Forderungen in der Praxis, insbesondere mit Git, darstellt wird in den
folgenden Unterkapiteln erläutert. Vorher werden aber noch einige benötigte
Grundbegriffe erläutert. 

\subsection{Commit}
Als Commit wird eine Sammlung von aktionen, die ist eine Sammlung von
\subsection{Tag}\label{sec:Tags}
\subsection{Branch}\label{sec:Branches}
\subsection{Merge}
\subsection{Repository}
\subsection{Integrität}

\section{Arten von Versionsverwaltungssystemen}
\subsection{Lokal}
Beide Systeme arbeiteten auf dem lokalen
Dateisystem.,
\subsection{Zentral}
\subsection{Verteilte}
\subsection{Streaming}

\label{sec:why}

